#!/usr/bin/env python3
import argparse
import os
import subprocess
import sys

src_abs_path = os.path.join(os.path.abspath(os.path.dirname(__file__)))
config_repos_path = os.path.join(src_abs_path, "sources_config")

WORKSPACES = ["dev", "src"]
WORKSPACES_STR = " ".join(WORKSPACES)
VCS_BIN = subprocess.check_output(["which", "vcs"]).strip()

DRYRUN_MODE = False
# DRYRUN_MODE = True  # comment for debugging

examples_checkout = """examples:
    %(prog)s beta
    %(prog)s beta
    %(prog)s beta --tag=1.6.17
    %(prog)s beta --tag=1.6.17 --no-reset
    %(prog)s --pull develop
    %(prog)s --pull --no-reset develop
"""

examples_global = """examples:
        %(prog)s status
        %(prog)s pull
        %(prog)s export
        %(prog)s checkout beta
        %(prog)s checkout beta --tag=1.6.17
        %(prog)s checkout beta --tag=1.6.17 --no-reset
        %(prog)s checkout --pull develop
        %(prog)s checkout --pull --no-reset develop
"""


### Utils
def run(command):
    print("$ {}".format(command))
    if not DRYRUN_MODE:
        subprocess.run(command, stdout=sys.stdout, stderr=sys.stderr, shell=True)


def perform_pull(workspaces):
    vcs_command = "vcs pull {}".format(workspaces)
    run(vcs_command)


def red(skk):
    print("\033[91m{}\033[00m".format(skk))


def ask(msg, default=True):
    if default:
        inp = input("{} [Y/n]".format(msg)).lower()
        return inp == "" or inp == "y"

    inp = input("{} [y/N]".format(msg)).lower()
    return not (inp == "" or inp == "n")


def choices_with_extension(dirr=config_repos_path):
    return [
        fname.split(".")[0]
        for fname in os.listdir(dirr)
        if os.path.isfile(os.path.join(dirr, fname)) and fname.endswith(".src")
    ]


def git_tags():
    tag_list = (
        subprocess.check_output(["git", "tag"]).decode("utf-8").strip().split("\n")
    )
    tag_list = sorted(tag_list)
    return tag_list


def get_vcs_file_path(tag, configuration, workspace):
    vcsfilename = "{}.{}".format(configuration, workspace)
    vcsfilepath = "{}/{}".format(config_repos_path, vcsfilename)
    if tag:
        # get file path for tag
        old_path_command = (
            "git ls-tree -r {tag} | grep {vcsfile} | awk -F' ' '{{print $NF}}'".format(
                tag=tag, vcsfile=vcsfilename
            )
        )
        print(old_path_command)
        vcsfilepath = (
            subprocess.check_output(old_path_command, shell=True)
            .decode("utf-8")
            .split("\n")[0]
        )
        if not vcsfilepath:
            red("Error: {} not found in tag {}".format(vcsfilename, tag))
            exit(1)
    return vcsfilepath


def get_vcs_config_command(configuration, workspace, tag="", shallow=False):
    vcsfile = get_vcs_file_path(tag, configuration, workspace)
    print(vcsfile)
    cmd = ""
    if tag:
        cmd = f"git show {tag}:{vcsfile} | vcs import --input - {workspace}"
    else:
        cmd = f"vcs import --input {vcsfile} {workspace}"
    if shallow:
        cmd += " --shallow"
    return cmd


def valid_tags():
    available_tags = git_tags()
    old_idx = available_tags.index(valid_tags.minimum_release_tag)

    def is_old(mytag):
        # check only tags like v1...
        if mytag.startswith("v"):
            idx = available_tags.index(mytag)
            return idx < old_idx
        return False

    return [x for x in available_tags if not is_old(x)]


valid_tags.minimum_release_tag = "v1.6.12"


def validate_tag(tag):
    actual_valid_tags = valid_tags()

    if tag.startswith("v"):
        print("Release tag detected.")
        if tag not in actual_valid_tags:
            red(
                f"Error: tag is too old for this functionality: {tag} < {valid_tags.minimum_release_tag}"
            )
            exit(1)

    if tag not in actual_valid_tags:
        optional = "" if tag[0].isalpha() else f", did you mean 'v{tag}'?"
        red(
            f"Provided tag '{tag}' not found{optional}\nValid tags:\n{actual_valid_tags}"
        )
        exit(1)


###

### Build parser
parser = argparse.ArgumentParser(
    epilog=examples_global, formatter_class=argparse.RawDescriptionHelpFormatter
)
subparser = parser.add_subparsers(help="Action to be performed", dest="command")
subparser.required = True
parser_pull = subparser.add_parser("pull", help="git pull every repository")
parser_status = subparser.add_parser("status", help="global git status check")
parser_checkout = subparser.add_parser(
    "checkout",
    help="point repositories to the corresponding branch/commit",
    epilog=examples_checkout,
    formatter_class=argparse.RawDescriptionHelpFormatter,
)
parser_export = subparser.add_parser(
    "export", help="show current list of repository and version"
)

group_checkout = parser_checkout.add_mutually_exclusive_group()
parser_checkout.add_argument(
    "--no-reset", dest="no_reset", help="do NOT delete workspace", action="store_true"
)
parser_checkout.add_argument(
    "--shallow", dest="shallow", help="perform a shallow cloning", action="store_true"
)
group_checkout.add_argument(
    "--pull", help="git pull every repository", action="store_true"
)
group_checkout.add_argument(
    "--tag",
    help="a GitHub tag specifying the version you want to restore",
    type=str,
    default="",
)
parser_checkout.add_argument(
    "configuration",
    help="corresponds to the workspace configuration (vcs files in {}/)".format(
        os.path.basename(config_repos_path)
    ),
    type=str,
    choices=choices_with_extension(),
)

args = parser.parse_args()
# print(args)

###
match args.command:
    case "pull":
        perform_pull(WORKSPACES_STR)
    case "status":
        vcs_command = "vcs status {}".format(WORKSPACES_STR)
        run(vcs_command)
    case "export":
        for workspace in WORKSPACES:
            vcs_command = "vcs export {}".format(workspace)
            run(vcs_command)
    case "checkout":
        # Check tag here and not in parser for help readability
        if args.tag:
            validate_tag(args.tag)

        # Asks for reset confirmation
        # TODO issue #47 to go back to --reset
        if not args.no_reset:
            red("--no-reset NOT provided, delete {}/?".format(WORKSPACES_STR))
            if not ask("Continue?", default=False):
                print("will not delete {}/".format(WORKSPACES_STR))
                exit(0)
            rm_command = "rm -rf {}".format(WORKSPACES_STR)
            run(rm_command)

        if args.pull:
            perform_pull(WORKSPACES_STR)

        for workspace in WORKSPACES:
            mkdir_command = "mkdir -pv {}".format(workspace)
            run(mkdir_command)

            vcs_command = get_vcs_config_command(
                args.configuration, workspace, args.tag, args.shallow
            )
            run(vcs_command)
    case _:
        red("impossible command ({}) reached".format(args.command))
        exit(1)
